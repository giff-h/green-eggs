import asyncio
import datetime
from types import TracebackType
from typing import AsyncIterator, ClassVar, Dict, List, Optional, Pattern, Tuple, Type, Union

from aiologger import Logger as Logger

from green_eggs.exceptions import ChannelPresenceRaceCondition as ChannelPresenceRaceCondition

BufferData = Tuple[str, datetime.datetime]
AUTH_EXPECT: str
CAP_REQ_EXPECT: str
JOIN_EXPECT: str
PART_EXPECT: str

def ensure_str(raw: Union[str, bytes]) -> str: ...
def format_oauth(oauth_token: str) -> str: ...

class TwitchChatClient:
    host: ClassVar[str]
    expectation_patterns: ClassVar[Dict[str, Pattern[str]]]
    ws_exc: Optional[Exception]
    def __init__(self, username: str, token: str, logger: Logger) -> None: ...
    async def buffer_messages(self) -> None: ...
    async def connect(self) -> None: ...
    async def expect(self, expectation: asyncio.Future, label: str, timeout: int = ...): ...
    async def filter_expected(self, data: str) -> AsyncIterator[str]: ...
    async def incoming(self) -> AsyncIterator[BufferData]: ...
    async def initialize(self) -> None: ...
    async def is_connected(self) -> bool: ...
    async def join(self, channel: str, action_if_leaving: str = ...) -> bool: ...
    async def leave(self, channel: str, action_if_joining: str = ...) -> bool: ...
    def manage_expectations(self, data: str) -> bool: ...
    def queue_expectations(self, category: str, *parts: str, timeout: int = ...) -> List[asyncio.Task]: ...
    async def recv(self) -> str: ...
    def resolve_expectations(self, category: str, *parts: str): ...
    async def send(self, data: str, redact_log: Optional[str] = ...): ...
    async def __aenter__(self) -> TwitchChatClient: ...
    async def __aexit__(
        self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[TracebackType]
    ): ...
